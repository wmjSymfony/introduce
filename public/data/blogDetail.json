[
  {
    "id":"1",
    "detail":"<p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span >1.首先有一个可以运行的React项目。如下图是一个空的React脚手架运行成功之后的结果。具体怎么新建一个React脚手架可以访问如下链接：</span></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><a href='https://www.jianshu.com/p/1e92a58987c7' >https://www.jianshu.com/p/1e92a58987c7</a></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span >2.修改自己的packjson文件。加入下面三条内容。其中如果有yarn。可以把predeploy改成这样 yarn run build</span></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span ><img src='./image/20190703/1562141708138885.png' title='1562141708138885.png' alt='image.png'/></span></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span >3.之后在远程新建一个仓库，把自己的项目push到远程。</span></p><span ><img src='./image/20190703/1562142960115045.png' title='1562142960115045.png' alt='image.png'/></span></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span >4.npm install gh-pages --save-dev 安装gh-pages工具。</span></p><span style=' color: rgb(47, 47, 47); '>5.npm run deploy 部署（如果有yarn可以使用yarn run deploy）。这一个命令可能执行时间会比较久，所以请耐心等待直到出现published。或者出现错误提示之后一步一步修改之后再重复push与npm run deploy。</span></p><p style='font-family: &quot;Microsoft YaHei&quot;; white-space: normal;'><span style=' color: rgb(47, 47, 47); '><img src='./image/20190703/1562144774123681.png' title='1562144774123681.png' alt='image.png'/></span></p><p><span style=' color: rgb(47, 47, 47); '>6.这个时候登录github打开相应仓库的settings能够发现有访问地址，通过这个访问地址</span></p><p><span style=' color: rgb(47, 47, 47); '><img src='./image/20190703/1562145051696254.png' title='1562145051696254.png' alt='image.png'/></span></p><p><span style=' color: rgb(47, 47, 47); '>7.之后修改代码后，先push上去，再执行npm run deploy（yarn run deploy）</span></p>"
  },
  {
    "id":"3",
    "detail":"<p>本文介绍了我在搭建自己的静态页面时的步骤。以及npm引用jquery等时的404问题(还是建议使用CND-内容分发网络引用jquery等)。</p><ol class=' list-paddingleft-2' style='list-style-type: decimal;'><li><p>在github上新建一个仓库。<br/></p></li><li><p>本地clone你的远程仓库。</p></li><li><p>把你的静态页面以及相关内容加入本地仓库，并且push到远程仓库（我的目录如下）。我在这里通过npm 下载了bootstrap，jquery。并且引入进去之后在本地访问正常。</p><p><img src='./image/20190703/1562161316396580.png' title='1562161316396580.png' alt='image.png'/><br/></p></li><li><p>进入setting，找到git pages。选择master分支。选择成功之后会页面自动刷新。再次进入setting之后会发现已经可以通过链接访问你的index.html文件</p><p><img src='./image/20190703/1562160941127851.png' title='1562160941127851.png' alt='image.png'/></p></li><li><p>如果你像我一样用了npm下载的jquery等等。放在git pages之后出现了找不到node_modules的问题。访问之后。404。</p><p><img src='./image/20190703/1562161378996874.png' title='1562161378996874.png' alt='image.png'/></p></li><li><p>此时在本地仓库新建一个.nojekyll文件夹并且push到远程仓库。404就消失了</p><p><img src='./image/20190703/1562161733189339.png' title='1562161733189339.png' alt='image.png'/></p></li><li><p><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'>这是因为</span><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(36, 39, 41); font-size: 15px; background-color: rgb(255, 255, 255);'>Github pages 用 jeklly来忽略 node_modules文件夹。至于jeklly是什么，由于并没有使用过所以我也了解了字面意思（感叹github的强大，越学越觉得自己知道的太少了。）。</span></p></li><li><p><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'><em>引用自官网</em>：Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 </span><a href='https://link.jianshu.com?t=http%3A%2F%2Fdaringfireball.net%2Fprojects%2Fmarkdown%2F' target='_blank' style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-decoration: underline;'><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'>Markdown</span></a><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'>）和我们的 </span><a href='https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FShopify%2Fliquid%2Fwiki' target='_blank' style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-decoration: underline;'><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'>Liquid</span></a><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'> 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 </span><a href='https://link.jianshu.com?t=http%3A%2F%2Fpages.github.com%2F' target='_blank' style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-decoration: underline;'><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'>GitHub Page</span></a><span style='font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;'> 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是<strong>完全免费</strong>的。</span></p></li></ol><p><br/></p><p>最后附上我的学习链接：<br/></p><p><a href='https://stackoverflow.com/questions/43481269/github-pages-404-on-node-modules-folder'>https://stackoverflow.com/questions/43481269/github-pages-404-on-node-modules-folder</a></p><p><br/></p><p><br/></p>"
  },{
  "id":"4",
  "detail":"<p><strong>一.window对象open方法通信</strong><br/></p><p>如果parent.html和child.html在本地电脑的目录下，会出现不同源的错误，需要放在服务器下，比如apache服务器。</p><h4 style=' padding: 0px; font-size: 14px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);'>window.open(URL,name,features,replace)</h4><p style=' padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);'><span style='font-family: 微软雅黑, '>URL:(可选)为空则打开空白新窗口。如果没有打开一个新的空白页面</span></p><p style=' padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);'><span style='font-family: 微软雅黑, '>Name:(可选)子窗口的句柄，声明新窗口的名称。</span></p><p style='padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);'><span style='font-family: 微软雅黑, '>Features (可选) 声明新窗口要显示的标准浏览器的特征(必须是打开空白窗口)。</span></p><p style=' padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255);'><span style='font-family: 微软雅黑, '>Replace(可选) 为true的话则替换浏览历史中的当前条目(返回回不去)，默认为false,创建新条目</span>。</p><p>1.在parent.html打开child.html。并操作child.html（利用window.open）<strong><br/></strong></p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>newWindow&nbsp;=&nbsp;window.open(&#39;child1.html&#39;,&#39;child&#39;);<br/>newWindow.document.body.innerHTML&nbsp;=&nbsp;&#39;父要求我添加&#39;;</pre><p>2.在child.html操作parent.html&nbsp;（利用window.opener）</p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>window.opener.document.body.innerHTML&nbsp;=&nbsp;&#39;子页面也能操作父页面!&#39;</pre><p><br/></p><p>二.<strong>利用postmessage通信</strong></p><p>postMessage方法被调用时，会在所有页面执行完毕之后向目标窗口派发一个message消息。</p><p>&nbsp;<span style='color: rgb(255, 70, 53);'>data</span>：为 postMessage 的第一个参数，是要传递的消息内容&nbsp; &nbsp;<span style='color: rgb(255, 70, 53);'>origin</span>：表示调用postMessage方法窗口的源 ,也就是要发送到的地方的源（协议+主机+端口号 [+url],url会被忽略，所以可以不写，这个参数是为了安全考虑）。如果表示全部用&#39;*&#39;&nbsp; &nbsp;<span style='color: rgb(255, 70, 53);'>source</span>：记录调用postMessage方法的窗口对象</p><p>1.在parent.html发送消息给child.html（child是parent的iframe）<strong><br/></strong></p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>document.getElementById(&quot;child&quot;).contentWindow.postMessage(messageContent,&#39;*&#39;)</pre><p>2.child.html接收parent.html发送的消息</p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>window.addEventListener(&#39;message&#39;,function(event){<br/>&nbsp;&nbsp;&nbsp;&nbsp;document.body.innerHTML&nbsp;+=&nbsp;event.data<br/>})</pre><p style='white-space: normal;'>3.在child.html发送消息给parent.html<strong><br/></strong></p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>parent.postMessage(messageContent,&#39;*&#39;)</pre><p style='white-space: normal;'>4.parent.html接收child.html发送的消息</p><pre style='background-color: rgb(43, 43, 43); font-size: 12pt; color: rgb(169, 183, 198); font-family: '>window.addEventListener(&#39;message&#39;,function(event){<br/>&nbsp;&nbsp;&nbsp;&nbsp;document.body.innerHTML&nbsp;+=&nbsp;event.data<br/>})</pre><p><br/></p>"
},
  {
    "id":"5",
    "detail":"<p><strong>三.frame通信</strong></p><p>1.parent.html调用child1.html（可以通过frames[&#39;framename&#39;]调用，还有其他方法）<strong><br/></strong></p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>frames[&#39;myChild1&#39;].say();</pre><p>2.child1.html调用child2.html（可以通过parent.frames[&#39;framename&#39;]调用，可以通过top.frames[&#39;framename&#39;]调用。其中top表示最外层框架，parent表示父框架）</p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>parent.frames[&#39;myChild2&#39;].say();<br/>top.frames[&#39;myChild2&#39;].say();</pre><p>3.child2.html调用parent.html （可以通过parent.变量/方法名调用，可以通过top..变量/方法名调用。其中top表示最外层框架，parent表示父框架）</p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>top.say();<br/>parent.say();</pre><p><br/></p><p><strong>四.iframe通信</strong></p><p>1.parent.html调用child.html（可以通过framename调用）<strong><br/></strong></p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>myChild.say();<br/>myChild.document.getElementById(&quot;button&quot;).value=&quot;调用结束&quot;;</pre><p>2.child.html调用parent.html（可以通过parent调用）</p><pre style='background-color:#2b2b2b;color:#a9b7c6;font-family:&#39;Source Code Pro&#39;;font-size:12.0pt;'>parent.say();<br/>parent.document.getElementById(&quot;button&quot;).value=&quot;调用结束&quot;;</pre><p><br/></p><p>以上四种方法，iframe可以通过document.domain设置同源来进行跨域。postMessgae也可以实现跨域。</p><p>最后附上以上四个方法我是的代码链接：</p><p><a href='https://github.com/wmjSymfony/introduce/tree/master/public/blogcode'>https://github.com/wmjSymfony/introduce/tree/master/public/blogcode</a></p>"
  }
]